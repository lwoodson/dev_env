# unit
snippet test class
	class Test${1:Class} < Test::Unit::TestCase
	  ${2}
	end
snippet test method
	def test_${1:case_name}
	  ${2}
	end
snippet testc
	class Test${1:Class} < Test::Unit::TestCase
	  ${2}
	end
snippet testm
	def test_${1:case_name}
	  ${2}
	end
snippet as
	assert(${1:test}, "${2:Failure message.}")${3}
snippet ase
	assert_equal(${1:expected}, ${2:actual})${3}
snippet asne
	assert_not_equal(${1:unexpected}, ${2:actual})${3}
snippet asid
	assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})${4}
snippet asio
	assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})${3}
snippet asko
	assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})${3}
snippet asn
	assert_nil(${1:instance})${2}
snippet asnn
	assert_not_nil(${1:instance})${2}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})${3}
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})${3}
snippet aso
	assert_operator(${1:left}, :${2:operator}, ${3:right})${4}
snippet asr
	assert_raise(${1:Exception}) { ${2} }
snippet asnr
	assert_nothing_raised(${1:Exception}) { ${2} }
snippet asrt
	assert_respond_to(${1:object}, :${2:method})${3}
snippet ass assert_same(..)
	assert_same(${1:expected}, ${2:actual})${3}
snippet ass assert_send(..)
	assert_send([${1:object}, :${2:message}, ${3:args}])${4}
snippet asns
	assert_not_same(${1:unexpected}, ${2:actual})${3}
snippet ast
	assert_throws(:${1:expected}) { ${2} }
snippet asnt
	assert_nothing_thrown { ${1} }
snippet fl
	flunk("${1:Failure message.}")${2}

# rspec example groups & examples
snippet desc
	describe ${1:Class} do
	  ${2}
	end
snippet ctx
	context "${1:desc}" do
	  ${2}
	end
snippet before
	before ${1::each} do
	  ${2}
	end
snippet it
	it "${1:should}" do
	  ${2}
	end
snippet spcfy
	specify "${1:something}" do
	  ${2}
	end
snippet xmpl
	example "${1:something}" do
	  ${2}
	end

# rspec should/should not
snippet s
	${1:target}.should ${2}
snippet sn
	${1:target}.should_not ${2}

# rspec expectations
snippet eq
	eq(${1:something})${2}
snippet ==
	eq(${1:something})${2}
snippet	be be(..)
	be(${1:something})${2}
snippet be be_xxx
	be_${1:predicate}${2}
snippet mtch
	match(/${1:regex}/)${2}
snippet	inst
	be_an_instance_of(${1:expected})${2}
snippet kind
	be_a_kind_of(${1:expected})${2}
snippet true
	be_true${1}
snippet false
	be_false${1}
snippet expect
	expect {${1:something}}.to ${2:do_what}
snippet	raise
	raise_error(${1:what})${2}
snippet throw
	throw_symbol(${1:symbol})${2}
snippet yield yield_control
	yield_control${1}
snippet yield yield_with_no_args
	yield_with_no_args
snippet yield yield_with_args(..)
	yield_with_args(${1:args})${2}
snippet yield yield_with_successive_args(..)
	yield_with_successive_args(${1:args})${2}
snippet cover
	cover(${1:what})${2}
snippet include
	include(${1:what})${2}
snippet start
	start_with(${1:what})${2}
snippet end
	end_with(${1:what})${2}

# factory girl
snippet fg
	require 'factory_girl'

	FactoryGirl.define do
	  ${1:# factory defs}
	end
snippet factory
	factory ${1:symbol} do
	  ${2:attributes}
	end
snippet fgc
	FactoryGirl.create ${1::symbol}
